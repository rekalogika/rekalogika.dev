"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[4205],{6696:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>s});var t=o(5893),i=o(1151);const c={title:"Lazy Chained Matching"},l=void 0,a={id:"doctrine-collections-decorator/cookbook/lazy-chained-matching",title:"Lazy Chained Matching",description:"If you call matching() on a PersistentCollection, it will immediately query",source:"@site/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md",sourceDirName:"doctrine-collections-decorator/cookbook",slug:"/doctrine-collections-decorator/cookbook/lazy-chained-matching",permalink:"/doctrine-collections-decorator/cookbook/lazy-chained-matching",draft:!1,unlisted:!1,editUrl:"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/doctrine-collections-decorator/cookbook/16-lazy-chained-matching.md",tags:[],version:"current",sidebarPosition:16,frontMatter:{title:"Lazy Chained Matching"},sidebar:"docs",previous:{title:"Loading Prevention in Extra Lazy Collections",permalink:"/doctrine-collections-decorator/cookbook/extra-lazy-load-prevention"},next:{title:"rekalogika/domain-event",permalink:"/domain-event/"}},r={},s=[{value:"The Decorator Class",id:"the-decorator-class",level:2},{value:"Usage Example in Entities",id:"usage-example-in-entities",level:2},{value:"The Caller Side",id:"the-caller-side",level:2}];function d(e){const n={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["If you call ",(0,t.jsx)(n.code,{children:"matching()"})," on a ",(0,t.jsx)(n.code,{children:"PersistentCollection"}),", it will immediately query\nthe database and return the result, even if you won't use the result. If you\ncall ",(0,t.jsx)(n.code,{children:"matching()"})," again on the result, it will be processed from the in-memory\n",(0,t.jsx)(n.code,{children:"ArrayCollection"}),", not from the database."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["With ",(0,t.jsx)(n.code,{children:"EXTRA_LAZY"})," fetch mode, ",(0,t.jsx)(n.code,{children:"PersistentCollection"})," will return a\n",(0,t.jsx)(n.code,{children:"LazyCriteriaCollection"}),". But subsequent ",(0,t.jsx)(n.code,{children:"matching()"})," call on the result\nwill still be processed immediately."]})}),"\n",(0,t.jsxs)(n.p,{children:["We can decorate the collection so that chained-",(0,t.jsx)(n.code,{children:"matching()"})," will be done lazily.\nThe database query will only be done when the caller asks for the result.\nCalling ",(0,t.jsx)(n.code,{children:"matching()"})," will only merge the supplied criteria to the existing\ncriteria."]}),"\n",(0,t.jsxs)(n.p,{children:["With the standard behavior, the following code will do the processing three\ntimes (twice with ",(0,t.jsx)(n.code,{children:"EXTRA_LAZY"}),"). With our decorator, it will only be done once\nwhen ",(0,t.jsx)(n.code,{children:"foreach"})," is called."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"/** @var Collection<array-key,mixed> $collection */\n/** @var Criteria $criteria1 */\n/** @var Criteria $criteria2 */\n/** @var Criteria $criteria3 */\n\n$result = $collection\n    ->matching($criteria1)\n    ->matching($criteria2)\n    ->matching($criteria3);\n\nforeach ($result as $item) {\n    // ...\n} \n"})}),"\n",(0,t.jsx)(n.h2,{id:"the-decorator-class",children:"The Decorator Class"}),"\n",(0,t.jsxs)(n.p,{children:["This package already comes with ",(0,t.jsx)(n.code,{children:"LazyMatchingCollection"})," that you can use for\nthis purpose."]}),"\n",(0,t.jsx)(n.h2,{id:"usage-example-in-entities",children:"Usage Example in Entities"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"use Doctrine\\Common\\Collections\\Collection;\nuse Doctrine\\ORM\\Mapping as ORM;\nuse Rekalogika\\Collections\\Decorator\\LazyMatching\\LazyMatchingCollection;\n\n#[ORM\\Entity()]\nclass BookShelf\n{\n    #[ORM\\OneToMany(targetEntity: Book::class, fetch: 'EXTRA_LAZY', indexBy: 'id')]\n    private Collection $books;\n\n    public function __construct()\n    {\n        $this->books = new ArrayCollection();\n    }\n\n    /**\n     * @return Collection<array-key,Book>&Selectable<array-key,Book>\n     */\n    public function getBooks(): Collection&Selectable\n    {\n        // highlight-next-line\n        return new LazyMatchingCollection($this->books);\n    }\n\n    public function getScienceBooks(): Collection\n    {\n        return $this->getBooks()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->eq('genre', 'science'))\n        );\n    }\n\n    public function getOldScienceBooks(): Collection\n    {\n        return $this->getScienceBook()->matching(\n            Criteria::create()\n                ->where(Criteria::expr()->lt('publishedAt', new \\DateTime('-10 years')))\n        );\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"the-caller-side",children:"The Caller Side"}),"\n",(0,t.jsx)(n.p,{children:"Then the caller will be able to do something like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-php",children:"$bookShelf = $entityManager->find(BookShelf::class, 1);\n\n$oldScienceBook = $bookShelf->getOldScienceBook();\n\nforeach ($oldScienceBook as $book) {\n    echo $book->getTitle();\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With this example, there will be only two database queries, one due to\n",(0,t.jsx)(n.code,{children:"$entityManager->find()"}),", and one due to the ",(0,t.jsx)(n.code,{children:"foreach"})," call."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,o)=>{o.d(n,{Z:()=>a,a:()=>l});var t=o(7294);const i={},c=t.createContext(i);function l(e){const n=t.useContext(c);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),t.createElement(c.Provider,{value:n},e.children)}}}]);