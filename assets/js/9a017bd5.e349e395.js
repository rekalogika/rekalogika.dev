"use strict";(self.webpackChunkrekalogika_docs=self.webpackChunkrekalogika_docs||[]).push([[7786],{69:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>c,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>t,toc:()=>p});const t=JSON.parse('{"id":"mapper/cookbook/overriding-transformer","title":"Overriding a Mapping Table Entry","description":"If the mapper chooses the wrong transformer for a specific source and target","source":"@site/docs/mapper/20-cookbook/02-overriding-transformer.md","sourceDirName":"mapper/20-cookbook","slug":"/mapper/cookbook/overriding-transformer","permalink":"/mapper/cookbook/overriding-transformer","draft":false,"unlisted":false,"editUrl":"https://github.com/rekalogika/rekalogika-docs/edit/main/docs/mapper/20-cookbook/02-overriding-transformer.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Overriding a Mapping Table Entry"},"sidebar":"docs","previous":{"title":"Mapping a DTO to a Persisted Doctrine Entity","permalink":"/mapper/cookbook/doctrine-entity"},"next":{"title":"Rationale, or Why Create Another Mapper?","permalink":"/mapper/rationale"}}');var o=n(4848),a=n(8453);const i={title:"Overriding a Mapping Table Entry"},s=void 0,c={},p=[];function d(e){const r={admonition:"admonition",code:"code",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(r.p,{children:"If the mapper chooses the wrong transformer for a specific source and target\ntype pair, you can override it by decorating the correct transformer and adding\nit to the mapping table."}),"\n",(0,o.jsx)(r.admonition,{type:"note",children:(0,o.jsx)(r.p,{children:'Note that in this case, we don\'t decorate the transformer to replace the\noriginal transformer in the dependency injection container. Instead, we are\n"duplicating" an existing transformer, override its type mapping information,\nand putting it earlier in the mapping table.'})}),"\n",(0,o.jsxs)(r.p,{children:["Suppose you have a ",(0,o.jsx)(r.code,{children:"YourObject"})," class and a ",(0,o.jsx)(r.code,{children:"YourObjectDto"})," class, but the\nmapper does not use the desired transformer for the job. You can fix it by\ndecorating the correct transformer like this:"]}),"\n",(0,o.jsx)(r.pre,{children:(0,o.jsx)(r.code,{className:"language-php",children:"use Rekalogika\\Mapper\\Transformer\\AbstractTransformerDecorator;\nuse Rekalogika\\Mapper\\Transformer\\ObjectToObjectTransformer;\nuse Rekalogika\\Mapper\\Transformer\\Contracts\\TypeMapping;\nuse Rekalogika\\Mapper\\Util\\TypeFactory;\n\nclass OverrideTransformer extends AbstractTransformerDecorator\n{\n    public function __construct(ObjectToObjectTransformer $transformer)\n    {\n        parent::__construct($transformer);\n    }\n\n    public function getSupportedTransformation(): iterable\n    {\n        yield new TypeMapping(\n            TypeFactory::objectOfClass(YourObject::class),\n            TypeFactory::objectOfClass(YourObjectDto::class),\n        );\n    }\n}\n"})}),"\n",(0,o.jsxs)(r.p,{children:["With the above example, when the source is ",(0,o.jsx)(r.code,{children:"YourObject"})," and the target is\n",(0,o.jsx)(r.code,{children:"YourObjectDto"}),", the mapper will now choose ",(0,o.jsx)(r.code,{children:"ObjectToObjectTransformer"})," instead\nof choosing from the rest of the mapping table."]})]})}function l(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>s});var t=n(6540);const o={},a=t.createContext(o);function i(e){const r=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),t.createElement(a.Provider,{value:r},e.children)}}}]);